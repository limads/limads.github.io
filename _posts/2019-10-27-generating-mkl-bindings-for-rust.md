---
layout: post
title: Linking against Intel Math Kernel Library (MKL) in Rust programs
---

While there was some progress in the Rust ecosystem in terms of [data structures for numerical linear algebra](https://github.com/rust-ndarray/ndarray), there are not many high performance algorithms with native implementations yet. Intel's  [MKL](https://software.intel.com/en-us/mkl) has recently been added to the Ubuntu repositories (in the 19.04 "disco" version), which makes it attractive as a binding solution for solving numerical problems in Rust. Several Linux distributions rely on those repositories, so users now don't have to go through the pain of manually installing the library. Despite being closed source, the library has excellent documentation and allows redistribution of its binaries under the ISSL license, making it a viable short-term solution if your application requires fast numerical computations.

The library can be installed in Ubuntu-based systems with (might vary for non-x64 architectures):

```shell
sudo apt install intel-mkl libmkl-scalapack-ilp64 libmkl-cdft-core intel-mkl-linktool
```

The installation script asks for the permission to make MKL the standard BLAS implementation on the system (which is not needed for the purposes of generating Rust bindings). Also, I suggest avoiding the packages `intel-mkl-full` and `libmkl-full-dev` as I've had some problems with them installing 32 bit libraries and breaking apt. After installation, the basic C linking flags can be checked with:

```shell
mkl_link_tool -c gnu_c -libs
```

The dynamic library linking flags output by the command (`-l*`) are the same linking flags that should be passed directly to rustc at the compilation step (or indirectly at the build.rs script if you are using Cargo).

Generating the bindings is surprisingly easy using the [bindgen](https://github.com/rust-lang/rust-bindgen) command line tool:

```shell
bindgen /usr/include/mkl/mkl_blas.h -o mkl_blas.rs --verbose --no-rustfmt-bindings
rustfmt mkl_blas.rs --force
```

Once the `.rs` file is generated from the MKL headers with bindgen, any generated symbols will automatically be resolved once you pass the right linking flags to `rustc`. In the example below, I just copy-pasted the generated `saxpy` function into a random source file to solve the problem of vector scaling followed by vector addition:

```rust
use std::os::raw::c_int;

// Automatically generated by bindgen
extern "C" {
    pub fn saxpy(
        n: *const ::std::os::raw::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: *const ::std::os::raw::c_int,
        y: *mut f32,
        incy: *const ::std::os::raw::c_int,
    );
}

fn try_saxpy() {

    let n = 4;
    let scale : f32 = 2.0;
    let x : [f32; 4] = [1.0, 1.0, 1.0, 1.0];
    let y : [f32; 4] = [1.0, 1.0, 0.0, 0.0];
    let inc_x : c_int = 1;
    let inc_y : c_int = 1;    

    unsafe{
        let x_ptr = &x as *const f32;
        let y_ptr =  y.as_ptr() as *mut f32;
        let n_ptr = &n as *const c_int;
        let scale_ptr = &scale as *const f32;
        saxpy(n_ptr, scale_ptr, x_ptr, &inc_x, y_ptr, &inc_y);    
    }

    println!("{:?}", y);
}

fn main() {
    try_saxpy();
}
```

Compile and run the program with (flags may differ - check the right ones with `mkl_link_tool -c gnu_c -libs`):

```
rustc saxpy.rs -o saxpy -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -liomp5 -lpthread -lm -ldl

./saxpy
# [3.0, 3.0, 2.0, 2.0]
```

Apart from being closed source, MKL also has the drawback of having its performance dependent on hardware vendor (See the [wiki](https://en.wikipedia.org/wiki/Math_Kernel_Library#Performance) and the referenced articles). For the set of functionality that MKL shares with open source high-performance numerical computing projects such as OpenBLAS, binding against the latter might be the best solution. But the library also offer an extensive collection of algorithms apart from the BLAS API such as FFTs, convolutions, statistical functions and even some deep learning functionality, which is hard to ignore if you want to build some high-performance numerical application in Rust today. The library is extensive, and it is a good option to write safe wrappers over it to jumpstart a scientific computing code base while the Rust ecosystem is catching up in terms of native implementations. 

Relevant links:

[MKL documentation](https://software.intel.com/en-us/mkl-developer-reference-c)

[bindgen documentation](https://rust-lang.github.io/rust-bindgen/introduction.html)

[Cargo documentation](https://doc.rust-lang.org/cargo/reference/build-scripts.html#case-study-building-some-native-code) (For building crates which use native code).

[BLAS specification wiki](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms#Level_1) (For saxpy and its sister functions).

Please leave any comments at [Twitter](https://twitter.com/limads4).
